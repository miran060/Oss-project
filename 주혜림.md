[2학기 JAVA – 이것이 자바다 핵심 이론 정리]
> PPT(01~06)에서 코드 제외, 이론 중심, 핵심 개념만 정리

-------------------------------------------------------

01. 프로그래밍 기초 & 개발 환경

[프로그래밍 언어란?]
- 컴퓨터와 소통하기 위한 표현 규칙
- 0과 1을 이해하기 쉽게 추상화한 도구

[JDK / JRE / JVM 구분]
▶ 구성 요소 & 설명
JDK  | 자바 개발 도구(컴파일러 포함)
JRE  | 자바 실행 환경
JVM  | 바이트코드를 실행하는 가상 머신

[개발 환경 구성]
- JDK 설치 및 환경 변수 설정
- Eclipse 설치 후 Java Project 생성

[Java 소스 구조]
- 패키지 → 클래스 → main 메소드
- 주석 종류: `//`, `/* */`, `/** */`
- 자바 주요 키워드: int, class, if, public, new 등

-------------------------------------------------------

02. 변수와 데이터 타입

[변수란?]
- 메모리 공간에 붙여진 이름
- 지역 변수는 반드시 초기화 필요

[변수명 규칙]
- lowerCamelCase 사용
- 클래스는 UpperCamelCase 사용
- 첫 글자는 문자, 중간에 `_` 또는 `$` 사용 가능

[데이터 타입]
▶ 기본 타입
- 정수: byte, short, int, long
- 실수: float, double
- 논리: boolean
- 문자: char(유니코드 기반)

▶ 참조 타입
- String, 배열, 클래스, 인터페이스 등

[문자열(String)]
- 문자열은 `" "` 로 표현
- escape 문자: `\n`, `\t`, `\"`, `\\`
- 텍스트 블록: `""" ... """`

[타입 변환]
- 자동 형변환: 작은 타입 → 큰 타입
- 강제 형변환(캐스팅): `(타입) 변수`
- byte, short, char → 연산 시 자동으로 int 승격

[입출력]
- import java.util.Scanner 사용
- `System.out.println()`, `printf()`
- `Scanner` 입력 처리

-------------------------------------------------------

03. 연산자

[연산자 종류]
- 부호/증감 연산자: `+`, `-`, `++`, `--`
- 산술 연산자: `+`, `-`, `*`, `/`, `%`
- 비교 연산자: `==`, `!=`, `>`, `<`, `>=`, `<=`
- 논리 연산자: `&&`, `||`, `!`, `^`
- 비트 연산자: `&`, `|`, `^`, `<<`, `>>`, `>>>`
- 대입 연산자: `=`, `+=`, `-=`, ...
- 삼항 연산자: `조건 ? 값1 : 값2`

[핵심 개념]
- 오버플로우 / 언더플로우
- 정수/실수 비교 시 정밀도 문제
- 문자열 비교는 `.equals()`
- `5 / 0.0 → Infinity`, `5 % 0.0 → NaN`
- 비트 연산은 2진수 기반으로 처리

-------------------------------------------------------

04. 제어문 (조건문, 반복문)

[조건문]
▶ if 계열
- `if`, `if-else`, `else-if`
- 조건식의 true/false 결과에 따라 분기

▶ switch문
- case 별 실행
- break가 없으면 다음 case로 계속 실행
- 문자, 정수, 문자열 분기 가능
- `yield`로 값 반환 가능

[반복문]
▶ for문
- 반복 횟수가 명확할 때 사용

▶ while문
- 조건이 true일 동안 반복

▶ do-while문
- 최소 한 번 실행 후 조건 판단

[흐름 제어]
- `break`: 반복문 종료
- `continue`: 다음 반복으로 건너뛰기
- 라벨 break: 중첩 반복문 한 번에 종료

-------------------------------------------------------

05. 문자열, 배열, JVM 메모리 구조

[JVM 메모리 구조]
▶ 영역 & 설명
Method Area  | 클래스 정보, static 저장
Heap         | 객체 저장
Stack        | 지역 변수 저장
PC Register  | 현재 실행 위치 저장
Native Stack | 네이티브 코드 실행 공간

[String]
- `==` : 참조(주소) 비교
- `.equals()` : 실제 문자열 내용 비교
- 주요 메소드
  * `length()`, `charAt()`, `substring()`, `indexOf()`, `replace()`, `split()`

[배열(Array)]
- 동일 타입의 연속된 메모리 공간
- 길이가 고정
- 복사
  * 얕은 복사(참조만 복사)
  * 깊은 복사(데이터까지 복사)
- 도구 메소드
  * `System.arraycopy()`, `clone()`, `Arrays.copyOf()`

[enum]
- 고정된 값 집합을 표현하는 자료형

-------------------------------------------------------

06. 객체지향 프로그래밍(OOP)

[절차지향 vs 객체지향]
- 절차지향: "어떻게" 중심
- 객체지향: "무엇을" 중심

[OOP 주요 개념 (4가지)]
1. 캡슐화 — 데이터 은닉 및 보호
2. 상속 — 부모 클래스의 기능을 재사용
3. 추상화 — 공통 특성만 추출
4. 다형성 — 동일 메소드 호출 → 다른 동작 수행

[클래스 구성 요소]
- 필드
  * public class Person{
      String name;
      int age;
    }
- 생성자
  * public Person(String name, int age){
      this.name = name;
      this.age = age;
    }
- 메소드
  * public void introduce(){
      System.out.println("이름: " + name + "나이: " + age);
    }

[static]
- 객체 생성 없이 접근 가능한 멤버
- 공용 데이터에 적합
- 인스턴스 변수, this 사용 불가

[final / 상수]
- final: 값 변경 불가
- 상수: `static final`, 보통 대문자로 표기

[패키지 / import]
- 클래스를 논리적으로 구분하는 디렉토리 구조
- 다른 패키지의 클래스를 사용할 때 import 필요

[Getter / Setter]
- private 필드를 안전하게 접근하기 위한 방식

[싱글톤 패턴]

- 인스턴스를 하나만 유지
- 공용 객체가 필요한 경우 사용
